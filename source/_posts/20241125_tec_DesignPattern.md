---
title: C++设计模式
category: 技术博客
mathjax: true
password: 12317003
date: 2024-11-25
---

# 第一章 理论基础

设计模式是对设计经验的显示表示。每个设计模式描述了一个反复出现的问题及其解法的核心内容。本章讲解累的构造、UML类图的组成，使用EIT造型拼接出设计模式。

## 1.1 类方法

## 1.2 类间关系

一个类内部权限分为：

```
+: 可见(public)
-: 不可见(private)
#: 保护(protected)
```

类间关系根据耦合强度由高到低分为：

1. 接口实现：派生类必须重写接口中的方法。虚线＋空心三角
2. 继承泛化关系：派生类继承基类，基类看做“一般设计”，派生类看做“特殊设计”。实线＋实心三角
3. 不可分离组合关系：整体与部分的关系，整体的生命周期与部分的生命周期一致。实线＋实心菱形
4. 可分离聚合关系：整体与部分的关系，整体的生命周期与部分的生命周期可以不一致。实线＋空心菱形
5. 关联关系：两个类在对象之间有关联，可以是单向或双向。实线＋箭头(单向)或实线＋箭头(双向)
6. 依赖关系：一个A类依赖另一个B类中的方法，一般在A的函数中传入B的对象，在函数中调用B的方法。虚线＋箭头

## 1.3 EIT造型

### 1.3.1 EIT造型的定义

EIT造型是一种用于表述雷雨类之间关系纽带的概念，把本无关系的单个类变成联系密切的亲戚。EIT把数学中自变量和因变量的关系引入到软件设计中，找到一种类似的“数学公式”。

EIT由三部分组成：E: Engine, I: Interface, T: Tire

基类E和派生类T之间通过接口I进行联系，I是E和T之间的纽带。                    

**书中第9页代码和第11页的图对不上，需要修改。且不理解为什么这么做，因为在Car中还是指定了唯一接口，接口中也指定了唯一派生类**

## 1.4 组合设计模式

软件架构设计的基础是抽离出公共部分进行复用，作为E；最主要的工作是设计出结构，作为I；最后设计出可更换的T。

# 第二章 六大设计原则

## 2.1 开闭原则

“开闭”是针对软件设计的拓展和修改两个方面的原则。软件设计应该是对拓展开放的，对修改封闭的。

## 2.2 里氏替换原则

里氏替换原则指的是子类型（subtype）必须能够替换掉它们的基类型（base type），并且程序的行为不会发生改变。

## 2.3 依赖倒置原则

它主要包括两个方面的内容：高层模块不应该依赖低层模块，二者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。

简单来说，就是在软件系统的设计中，应该尽量避免让高层级的模块直接依赖低层级的具体模块，而是通过抽象（如接口或抽象类）来建立它们之间的关系。这样可以降低模块之间的耦合度，提高系统的可维护性和可扩展性。

## 2.4 单一职责原则

它规定一个类应该只有一个引起它变化的原因。换句话说，一个类应该只负责一项职责。

这里的 “职责” 可以理解为一个类所承担的功能或者任务。例如，如果一个类既负责数据的存储又负责数据的展示，那么它就有两个职责，这可能会导致代码的复杂性增加和维护的困难。

## 2.5 接口隔离原则

一个接口中的方法应该尽量少，接口的粒度应该尽量小。降低后合度，提升代码可读性，便于维护。

## 2.6 迪米特法则

类的设计对外暴露的方法应该尽量少，使用最少的方法说明类的设计。

## 2.7 总结

|设计原则|核心|作用|
|--|--|--|
|开闭原则|软件实体（类、模块、函数等）应该对扩展开放，对修改关闭|使得软件系统在面对新需求时，能够通过扩展来实现功能的增加，而尽量避免修改原有代码，提高软件的可维护性和稳定性|
|里氏替换原则|子类型能替换基类型，程序行为不变|保证程序在使用子类替换父类时的正确性和稳定性，提高软件的可维护性和扩展性|
|依赖倒置原则|高层和低层模块都依赖抽象，抽象不依赖细节，细节依赖抽象|降低模块间耦合度，提高系统的可维护性、可扩展性和代码复用性|
|单一职责原则|一个类只有一个引起变化的原因，只负责一项职责|提高代码的可维护性、复用性，增强可读性，便于功能修改和扩展|
|接口隔离原则|客户端不依赖不需要的接口，类对另一个类的依赖建立在最小接口上|降低耦合度，提高代码可读性，便于维护和扩展|
|迪米特法则|一个对象对其他对象有最少的了解，尽可能少地与其他实体相互作用|降低耦合度，提高可维护性和代码可读性|

# 第三章 创建型设计模式

## 3.1 单例模式

单例模式是一种常见的设计模式，它保证一个类只有一个实例，并提供一个全局访问点。

- 构造函数设置为private
- 提供一个static方法获取实例
- 多线程下需要加锁

## 3.2 原型模式

它允许通过复制现有对象（原型）来创建新对象。通过在类中实现一个clone方法，可以实现原型模式。注意有可能会有浅拷贝和深拷贝的问题。

## 3.3 工厂方法模式

它的主要目的是将对象的创建和使用分离。通过一个工厂类来负责创建对象，而不是让客户端代码直接使用`new`操作符来创建对象。这样做的好处是可以更灵活地控制对象的创建过程，例如根据不同的条件创建不同类型的对象，或者在创建对象时进行一些初始化操作。

优点：符合开闭原则。当需要添加新的产品类型时，只需要创建一个新的具体工厂子类和新的产品子类，不需要修改现有的工厂类和产品类。这样可以很好地应对软件系统的扩展。

缺点：工厂子类和产品子类的数量会随着产品类型的增加而增加，可能会导致代码结构变得复杂。

## 3.4 抽象工厂模式

抽象工厂模式是工厂模式的更高级抽象。它提供了一个接口，用于创建一系列相关的产品对象。即对工厂要生产的产品进行抽象，然后由具体的工厂子类来实现这个接口，从而生产不同类型的产品。

优点：可以确保创建的产品对象之间的兼容性。当需要创建一组相关的产品对象时，通过抽象工厂模式可以很好地组织代码，并且很容易替换整个产品系列。

缺点：抽象工厂模式的实现比较复杂，需要定义多个抽象类和具体类，并且客户端代码在使用时也需要理解比较复杂的对象创建层次结构。

## 3.5 简单工厂模式

工厂对象通过其方法中的形参变量来决定创建哪一种产品对象。与其他工厂模式不同的是，简单工厂模式只有一个工厂类，不存在基类和派生类的关系。

## 3.6 建造者模式

它将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。该模式把对象的创建过程分解为多个步骤，通过一个指挥者（Director）来控制这些步骤的执行顺序，而具体的构建工作则由建造者（Builder）类来完成。

缺点：代码复杂性增加；需要额外的开发成本。

# 第四章 七大结构型设计模式

结构性设计模式考虑的是如何将各个类对象结合在一起形成一个更复杂更完整的系统。

## 4.1 适配器模式

主要作用是将一个类的接口转换成另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。就像是一个电源适配器，它可以把一种插头类型转换为另一种插头类型，让电器能够在不同的插座上使用。

## 4.2 代理模式

它为其他对象提供一种代理，以控制对这个对象的访问。代理对象和被代理对象（真实对象）实现相同的接口，这样在客户端看来，代理对象和真实对象是一样的，但是代理对象可以在访问真实对象之前或之后添加一些额外的操作。

优点：增强功能，保护目标对象，添加额外逻辑控制访问。

缺点：增加复杂度，降低性能。

## 4.3 桥接模式

将抽象部分与它的实现部分分离，使它们可以独立地变化。这种模式通过使用组合关系而不是继承关系来实现抽象和实现的解耦。

优点：

分离抽象和实现：使得抽象部分和实现部分可以独立地扩展和修改。例如，在软件的图形系统中，可以独立地添加新的图形形状（抽象部分）和新的绘制算法或工具（实现部分），而不会相互干扰。

提高可维护性和可扩展性：由于抽象和实现的解耦，当系统需要进行修改或扩展时，只需要关注相应的抽象部分或实现部分，降低了代码的复杂性，提高了代码的可维护性和可扩展性。

实现细节对客户端透明：客户端只需要和抽象部分交互，不需要了解具体的实现细节。这使得客户端代码更加简洁，并且可以很容易地替换实现方式而不影响客户端的使用。

缺点：增加系统复杂度，设计难度增加。

## 4.4 装饰模式

允许在运行时动态地给对象添加新的功能。这种模式通过创建装饰类来包裹原始对象，装饰类和原始对象实现相同的接口，在装饰类中可以在调用原始对象方法的基础上添加额外的行为。

实现时，可以在有A基类和B派生类的情况下，通过创建C派生类，并在C中包含B的对象，然后在C中调用B，实现A的方法。此时，C就是B的装饰类。

## 4.5 外观模式

它为子系统中的一组接口提供一个统一的高层接口，这个接口使得子系统更容易使用。外观模式隐藏了子系统的复杂性，将客户端与子系统的复杂交互封装在一个简单的接口后面，就像给复杂的机器设备安装了一个简单的控制面板。

优点：简化子系统的使用，提高了可维护性，增强系统可移植性。

缺点：不符合开闭原则，一旦要增加或修改子系统的功能，可能需要修改外观类。且可能会造成代码冗余。

## 4.6 享元模式

它主要用于减少创建对象的数量，以减少内存占用和提高性能。该模式通过共享对象来实现这一目的，将对象的状态分为内部状态（可以被共享的状态）和外部状态（不能被共享的状态），尽可能地共享内部状态相同的对象。

可能需要一个工厂类来管理对象的创建和共享。类似于对象池、线程池等。

## 4.7 组合模式

它允许将对象组合成树形结构来表示 “部分 - 整体” 的层次关系。组合模式使得客户端对单个对象和组合对象的使用具有一致性，即客户端可以以相同的方式处理单个对象和由多个对象组成的组合对象。

例如一个基类向量，可以同时包含多种派生类对象。