---
title: C++设计模式
category: 技术博客
mathjax: true
password: 12317003
date: 2024-11-25
---

# 第一章 理论基础

设计模式是对设计经验的显示表示。每个设计模式描述了一个反复出现的问题及其解法的核心内容。本章讲解累的构造、UML类图的组成，使用EIT造型拼接出设计模式。

## 1.1 类方法

## 1.2 类间关系

一个类内部权限分为：

```
+: 可见(public)
-: 不可见(private)
#: 保护(protected)
```

类间关系根据耦合强度由高到低分为：

1. 接口实现：派生类必须重写接口中的方法。虚线＋空心三角
2. 继承泛化关系：派生类继承基类，基类看做“一般设计”，派生类看做“特殊设计”。实线＋实心三角
3. 不可分离组合关系：整体与部分的关系，整体的生命周期与部分的生命周期一致。实线＋实心菱形
4. 可分离聚合关系：整体与部分的关系，整体的生命周期与部分的生命周期可以不一致。实线＋空心菱形
5. 关联关系：两个类在对象之间有关联，可以是单向或双向。实线＋箭头(单向)或实线＋箭头(双向)
6. 依赖关系：一个A类依赖另一个B类中的方法，一般在A的函数中传入B的对象，在函数中调用B的方法。虚线＋箭头

## 1.3 EIT造型

### 1.3.1 EIT造型的定义

EIT造型是一种用于表述雷雨类之间关系纽带的概念，把本无关系的单个类变成联系密切的亲戚。EIT把数学中自变量和因变量的关系引入到软件设计中，找到一种类似的“数学公式”。

EIT由三部分组成：E: Engine, I: Interface, T: Tire

基类E和派生类T之间通过接口I进行联系，I是E和T之间的纽带。                    

**书中第9页代码和第11页的图对不上，需要修改。且不理解为什么这么做，因为在Car中还是指定了唯一接口，接口中也指定了唯一派生类**

## 1.4 组合设计模式

软件架构设计的基础是抽离出公共部分进行复用，作为E；最主要的工作是设计出结构，作为I；最后设计出可更换的T。

# 第二章 六大设计原则

## 2.1 开闭原则

“开闭”是针对软件设计的拓展和修改两个方面的原则。软件设计应该是对拓展开放的，对修改封闭的。

## 2.2 里氏替换原则

里氏替换原则指的是子类型（subtype）必须能够替换掉它们的基类型（base type），并且程序的行为不会发生改变。

## 2.3 依赖倒置原则

它主要包括两个方面的内容：高层模块不应该依赖低层模块，二者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。

简单来说，就是在软件系统的设计中，应该尽量避免让高层级的模块直接依赖低层级的具体模块，而是通过抽象（如接口或抽象类）来建立它们之间的关系。这样可以降低模块之间的耦合度，提高系统的可维护性和可扩展性。

## 2.4 单一职责原则

它规定一个类应该只有一个引起它变化的原因。换句话说，一个类应该只负责一项职责。

这里的 “职责” 可以理解为一个类所承担的功能或者任务。例如，如果一个类既负责数据的存储又负责数据的展示，那么它就有两个职责，这可能会导致代码的复杂性增加和维护的困难。

## 2.5 接口隔离原则

一个接口中的方法应该尽量少，接口的粒度应该尽量小。降低后合度，提升代码可读性，便于维护。

## 2.6 迪米特法则

类的设计对外暴露的方法应该尽量少，使用最少的方法说明类的设计。

## 2.7 总结

|设计原则|核心|作用|
|--|--|--|
|开闭原则|软件实体（类、模块、函数等）应该对扩展开放，对修改关闭|使得软件系统在面对新需求时，能够通过扩展来实现功能的增加，而尽量避免修改原有代码，提高软件的可维护性和稳定性|
|里氏替换原则|子类型能替换基类型，程序行为不变|保证程序在使用子类替换父类时的正确性和稳定性，提高软件的可维护性和扩展性|
|依赖倒置原则|高层和低层模块都依赖抽象，抽象不依赖细节，细节依赖抽象|降低模块间耦合度，提高系统的可维护性、可扩展性和代码复用性|
|单一职责原则|一个类只有一个引起变化的原因，只负责一项职责|提高代码的可维护性、复用性，增强可读性，便于功能修改和扩展|
|接口隔离原则|客户端不依赖不需要的接口，类对另一个类的依赖建立在最小接口上|降低耦合度，提高代码可读性，便于维护和扩展|
|迪米特法则|一个对象对其他对象有最少的了解，尽可能少地与其他实体相互作用|降低耦合度，提高可维护性和代码可读性|

# 第三章 创建型设计模式

## 3.1 单例模式

单例模式是一种常见的设计模式，它保证一个类只有一个实例，并提供一个全局访问点。

- 构造函数设置为private
- 提供一个static方法获取实例
- 多线程下需要加锁

## 3.2 原型模式

它允许通过复制现有对象（原型）来创建新对象。通过在类中实现一个clone方法，可以实现原型模式。注意有可能会有浅拷贝和深拷贝的问题。

## 3.3 工厂方法模式

它的主要目的是将对象的创建和使用分离。通过一个工厂类来负责创建对象，而不是让客户端代码直接使用`new`操作符来创建对象。这样做的好处是可以更灵活地控制对象的创建过程，例如根据不同的条件创建不同类型的对象，或者在创建对象时进行一些初始化操作。

优点：符合开闭原则。当需要添加新的产品类型时，只需要创建一个新的具体工厂子类和新的产品子类，不需要修改现有的工厂类和产品类。这样可以很好地应对软件系统的扩展。

缺点：工厂子类和产品子类的数量会随着产品类型的增加而增加，可能会导致代码结构变得复杂。

## 3.4 抽象工厂模式

抽象工厂模式是工厂模式的更高级抽象。它提供了一个接口，用于创建一系列相关的产品对象。即对工厂要生产的产品进行抽象，然后由具体的工厂子类来实现这个接口，从而生产不同类型的产品。

优点：可以确保创建的产品对象之间的兼容性。当需要创建一组相关的产品对象时，通过抽象工厂模式可以很好地组织代码，并且很容易替换整个产品系列。

缺点：抽象工厂模式的实现比较复杂，需要定义多个抽象类和具体类，并且客户端代码在使用时也需要理解比较复杂的对象创建层次结构。

## 3.5 简单工厂模式

工厂对象通过其方法中的形参变量来决定创建哪一种产品对象。与其他工厂模式不同的是，简单工厂模式只有一个工厂类，不存在基类和派生类的关系。

## 3.6 建造者模式

它将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。该模式把对象的创建过程分解为多个步骤，通过一个指挥者（Director）来控制这些步骤的执行顺序，而具体的构建工作则由建造者（Builder）类来完成。

缺点：代码复杂性增加；需要额外的开发成本。

# 第四章 七大结构型设计模式

结构性设计模式考虑的是如何将各个类对象结合在一起形成一个更复杂更完整的系统。

## 4.1 适配器模式

主要作用是将一个类的接口转换成另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。就像是一个电源适配器，它可以把一种插头类型转换为另一种插头类型，让电器能够在不同的插座上使用。

## 4.2 代理模式

它为其他对象提供一种代理，以控制对这个对象的访问。代理对象和被代理对象（真实对象）实现相同的接口，这样在客户端看来，代理对象和真实对象是一样的，但是代理对象可以在访问真实对象之前或之后添加一些额外的操作。

优点：增强功能，保护目标对象，添加额外逻辑控制访问。

缺点：增加复杂度，降低性能。

## 4.3 桥接模式

将抽象部分与它的实现部分分离，使它们可以独立地变化。这种模式通过使用组合关系而不是继承关系来实现抽象和实现的解耦。

优点：

分离抽象和实现：使得抽象部分和实现部分可以独立地扩展和修改。例如，在软件的图形系统中，可以独立地添加新的图形形状（抽象部分）和新的绘制算法或工具（实现部分），而不会相互干扰。

提高可维护性和可扩展性：由于抽象和实现的解耦，当系统需要进行修改或扩展时，只需要关注相应的抽象部分或实现部分，降低了代码的复杂性，提高了代码的可维护性和可扩展性。

实现细节对客户端透明：客户端只需要和抽象部分交互，不需要了解具体的实现细节。这使得客户端代码更加简洁，并且可以很容易地替换实现方式而不影响客户端的使用。

缺点：增加系统复杂度，设计难度增加。

## 4.4 装饰模式

允许在运行时动态地给对象添加新的功能。这种模式通过创建装饰类来包裹原始对象，装饰类和原始对象实现相同的接口，在装饰类中可以在调用原始对象方法的基础上添加额外的行为。

实现时，可以在有A基类和B派生类的情况下，通过创建C派生类，并在C中包含B的对象，然后在C中调用B，实现A的方法。此时，C就是B的装饰类。

## 4.5 外观模式

它为子系统中的一组接口提供一个统一的高层接口，这个接口使得子系统更容易使用。外观模式隐藏了子系统的复杂性，将客户端与子系统的复杂交互封装在一个简单的接口后面，就像给复杂的机器设备安装了一个简单的控制面板。

优点：简化子系统的使用，提高了可维护性，增强系统可移植性。

缺点：不符合开闭原则，一旦要增加或修改子系统的功能，可能需要修改外观类。且可能会造成代码冗余。

## 4.6 享元模式

它主要用于减少创建对象的数量，以减少内存占用和提高性能。该模式通过共享对象来实现这一目的，将对象的状态分为内部状态（可以被共享的状态）和外部状态（不能被共享的状态），尽可能地共享内部状态相同的对象。

可能需要一个工厂类来管理对象的创建和共享。类似于对象池、线程池等。

## 4.7 组合模式

它允许将对象组合成树形结构来表示 “部分 - 整体” 的层次关系。组合模式使得客户端对单个对象和组合对象的使用具有一致性，即客户端可以以相同的方式处理单个对象和由多个对象组成的组合对象。

例如一个基类向量，可以同时包含多种派生类对象。

# 第五章 行为型设计模式

行为型设计模式关注的是对象之间的通信，以及对象之间的协作。这些模式涉及到算法和对象间职责的分配。

## 5.1 模板方法模式

 在一个方法中定义了一个算法的骨架，将一些步骤的实现延迟到子类中。这个模板方法定义了算法的步骤顺序，而具体的步骤实现可以在子类中根据不同的需求进行定制，就像制作某种产品有一个标准的工艺流程，但是某些具体工序的操作细节可以根据产品的不同而变化。

 ## 5.2 解释器模式

 用于定义一种语言的语法规则，并对该语言中的句子进行解释执行。它将语言中的每一个语法规则表示为一个类，通过这些类的组合来解释整个句子的含义，就像编译器对编程语言进行词法分析和语法分析一样。

 添加新类型的表达式时，只需要增加一个新的解释器类即可。

## 5.3 策略模式

它定义了一系列算法，将每个算法封装起来，并使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户，使得算法可以在不影响客户端的情况下灵活地改变。

可以添加一层上下文类，在类中包含一个策略类的对象，在不同的策略类中实现不同算法。用户只需要调用上下文类的方法，而不需要关心具体的策略类。

## 5.4 命令模式

它将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。这种模式将请求发送者和请求接收者解耦，请求的发送者不需要知道请求是如何被处理的，只需要发出命令即可。

优点：解耦请求发送者和接收者，支持命令的排队和撤销，支持日志记录，方便组合命令。

缺点：可能会导致系统中命令类过多，增加系统复杂度。

## 5.5 责任链模式

它将多个对象组成一条链，请求在这条链上传递，直到有一个对象处理该请求为止。链上的每个对象都有机会处理请求，并且可以决定是否将请求传递给下一个对象。

## 5.6 状态模式

它允许一个对象在其内部状态改变时改变它的行为。对象看起来好像修改了它的类，实际上是通过改变对象的内部状态来改变其行为，而这些状态是由不同的状态类来表示的。

## 5.7 观察者模式

它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，它会通知所有观察者对象，使它们能够自动更新自己的状态。

## 5.8 中介者模式

它通过引入一个中介者对象来封装一系列对象之间的交互，使得这些对象之间的耦合松散，它们只需要和中介者对象进行通信，而不需要直接相互引用。中介者对象协调各个对象之间的交互，就像一个交通警察指挥交通一样。

优点：减少对象之间的直接交互，降低耦合度，集中控制交互逻辑，易于扩展。

缺点：中介者对象可能会变得过于复杂，难以维护。

## 5.9 访问者模式

它将数据结构与作用于结构上的操作解耦，使得操作可以相对独立地变化。该模式允许在不改变数据结构的前提下定义作用于这些结构的新操作，主要用于对对象结构中的元素进行多种不同但相关的操作。

## 5.10 备忘录模式

它用于保存一个对象的某个状态，以便在需要的时候能够恢复到这个状态。该模式通过一个备忘录对象来存储原发器对象的内部状态，并且可以在不破坏封装性的前提下，将备忘录对象存储在原发器对象之外。